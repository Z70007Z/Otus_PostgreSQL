
# Практика №12 "Хранимые функции и процедуры часть 3."
# 1. Создать инстанс ВМ с 2 ядрами и 4 Гб ОЗУ и HDD 20GB.

Была создана виртуальная машина:

1. ОС - Ubuntu 24.04 LTS
2. Выделено минимально количество ресурсов
    - CPU 2 
    - RAM 4 ГБ
    - Диск HDD 20 Гб
    - Прерываемая - Да

3. В Дефолтной сети создал подсетку:
    - Имя: otus-vm-db-pg-net-1
    - ip адресация: 10.10.8.0/24
    - Динамический публичный IP адрес

4. Имя VM - otus-db-pg-vm-12

5. Для подключения по SSH воспользовался ранее сгенерированным ключом, во время создания VM указал публичный ключ.

Для подключения использовал  ПО PuTTy, можно так же Powershell и другое ПО.

#

# 2. Установить на него PostgreSQL 15 с дефолтными настройками.
```bash

# https://www.ubuntumint.com/install-postgresql-in-ubuntu/

sudo apt update && sudo apt upgrade -y
# Сначала нужно импортировать ключ PostgreSQL GPG для проверки подлинности установочного пакета:
curl -fSsL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg > /dev/null
# Импортируем стабильный репозиторий PostgreSQL 15, который, как следует из названия, содержит последнюю безопасную, рабочую и стабильную версию
echo deb [arch=amd64,arm64,ppc64el signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main | sudo tee /etc/apt/sources.list.d/postgresql.list
# Теперь нужжно обновить список источников репозитория, чтобы он отражал новые дополнения. Для этого выполним следующую команду:
sudo apt update -y
# Установка PostgreSQL с помощью следующей команды
sudo apt install postgresql-client-15 postgresql-15 -y

# Следующая команда выведет список всех пакетов, связанных с вашей установкой PostgreSQL
dpkg -l | grep postgresql
# Приведенная выше команда выводит список всех системных процессов, использующих/прослушивающих порт 5432
sudo ss -atnp | grep 5432
# Затем перезапустите PostgreSQL, чтобы он продолжал работать даже после перезагрузки системы Ubuntu, и проверьте статус PostgreSQL, чтобы убедиться, что он работает
sudo systemctl restart postgresql
sudo systemctl enable postgresql
sudo systemctl status postgresql

# Проверяем какой кластер запущен
pg_lsclusters
# или
sudo -u postgres pg_lsclusters

Ver Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log

# Картинка с выполненными командами ранее о статусе кластера (Картинка ниже!):
```
![Статус кластера](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema11/picture/status_cluster.jpg "Статус кластера")

#
# Выполнение подготовительных шагов до создания триггера!
```bash

# Входим в psql:
sudo -u postgres psql

# Удаляем схему если она есть
postgres=# DROP SCHEMA IF EXISTS pract_functions CASCADE;
    NOTICE:  schema "pract_functions" does not exist, skipping
    DROP SCHEMA

# Создаем схему pract_functions:
postgres=# CREATE SCHEMA pract_functions;
    CREATE SCHEMA

# Добавляем схему для поиска:
SET search_path = pract_functions, publ;

# Создаем таблицу товары:
CREATE TABLE goods
(
    goods_id    integer PRIMARY KEY,
    good_name   varchar(63) NOT NULL,
    good_price  numeric(12, 2) NOT NULL CHECK (good_price > 0.0)
);

# Перейти в схему и добавить данные.
INSERT INTO goods (goods_id, good_name, good_price)
VALUES 	(1, 'Спички хозайственные', .50),
		(2, 'Автомобиль Ferrari FXX K', 185000000.01);

# # Создаем таблицу Продажи:
CREATE TABLE sales
(
    sales_id    integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    good_id     integer REFERENCES goods (goods_id),
    sales_time  timestamp with time zone DEFAULT now(),
    sales_qty   integer CHECK (sales_qty > 0)
);

# Добавляем данные в таблицу Продажи:
INSERT INTO sales (good_id, sales_qty) VALUES (1, 10), (1, 1), (1, 120), (2, 1);

# Проверям что данные есть:
postgres=# SELECT G.good_name, sum(G.good_price * S.sales_qty)
    FROM goods G
    INNER JOIN sales S ON S.good_id = G.goods_id
    GROUP BY G.good_name;

            good_name         |     sum      
    --------------------------+--------------
    Автомобиль Ferrari FXX K | 185000000.01
    Спички хозайственные     |        65.50
    (2 rows)

# -- с увеличением объёма данных отчет стал создаваться медленно
# -- Принято решение денормализовать БД, создать таблицу
CREATE TABLE good_sum_mart
(
    good_name   varchar(63) NOT NULL,
    sum_sale	numeric(16, 2) NOT NULL
);

# -- Создать триггер (на таблице sales) для поддержки.
# -- Подсказка: не забыть, что кроме INSERT есть еще UPDATE и DELETE

# -- Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
# -- Подсказка: В реальной жизни возможны изменения цен.

```
#
# Создать триггер на таблице продаж, для поддержки данных в витрине в актуальном состоянии (вычисляющий при каждой продаже сумму и записывающий её в витрину)
## Самый простой, но кривой вариант:
```bash 

# Удаление функции
DROP FUNCTION IF EXISTS check_sales;
# Удаление триггера
DROP TRIGGER check_sales_trigger ON "sales";

# Для начала попробовал написать вот такое: 
#------------------------------------------
# А именно Триггер - check_sales_trigger 
# Смотрит за операциями - INSERT OR UPDATE OR DELETE в таблице sales, как только такая замечена, то:
# Запускается функция check_sales(), которая удаляем все в таблице good_sum_mart и
# заполняет новыми данными на основе таблицы - sales:
    CREATE OR REPLACE FUNCTION check_sales()
    RETURNS trigger
    AS
    $$
    DECLARE
        data_row record;
    BEGIN

        IF TG_LEVEL = 'ROW' THEN
            CASE TG_OP
                WHEN 'DELETE'
                    THEN data_row = OLD;
                WHEN 'UPDATE'
                    THEN data_row = NEW;
                WHEN 'INSERT'
                    THEN data_row = NEW; 
            END CASE;
        END IF;

        -- Удаляю все что было в таблице
        TRUNCATE TABLE good_sum_mart;
        
        -- Записываю результат запроса с объединением таблиц goods и sales в таблицу good_sum_mart.
        INSERT INTO good_sum_mart (good_name, sum_sale) 
        SELECT G.good_name, sum(G.good_price * S.sales_qty)
        FROM goods G
        INNER JOIN sales S ON S.good_id = G.goods_id
        GROUP BY G.good_name;

        RETURN data_row;		

    END;
    $$  LANGUAGE plpgsql
        SET search_path = pract_functions, public;
        
# Не посредственно создание триггера на операции с таблицей "sales"  
    CREATE TRIGGER check_sales_trigger
    AFTER INSERT OR UPDATE OR DELETE
    ON "sales"
    FOR EACH ROW
    EXECUTE PROCEDURE check_sales();
# Вроде как работает, но не хорошо так делать, пересчет происходить постоянно и для каждого товара.
# Нужно переписать функцию.


```
##
## Хороший вариант функции для триггера.
```bash
DROP FUNCTION IF EXISTS check_sales;
DROP TRIGGER check_sales_trigger ON "sales";

# Более точный, может и красивый вариант:
# Триггер не поменялся, а вот вычисления в функции да:
# Даже есть проверка если вычисления не производились никогда для таблицы - good_sum_mart.     
CREATE OR REPLACE FUNCTION check_sales()
RETURNS trigger
AS
$$
DECLARE
    data_row record;
    data_str text = '';
    sum_sale_R   good_sum_mart.sum_sale%TYPE;
	good_name_R	 good_sum_mart.good_name%TYPE;
    good_price_R goods.good_price%TYPE;
	good_id_old int = 0;
	sales_qty_old int = 0;
	good_id_new int = 0;
	sales_qty_new int = 0;
	qwe int = 0;
BEGIN
    -- Проверям какая операция прошла и забираем данные в переменные:
    IF TG_LEVEL = 'ROW' THEN
        CASE TG_OP
            WHEN 'DELETE'
                THEN data_row = OLD; data_str = OLD::text;
				good_id_old   = OLD.good_id::int;
				sales_qty_old = OLD.sales_qty::int;
            WHEN 'UPDATE'
                THEN data_row = NEW; data_str = 'UPDATE FROM ' || OLD || ' TO ' || NEW;
				good_id_old   = OLD.good_id::int;
				sales_qty_old = OLD.sales_qty::int;
				good_id_new   = NEW.good_id::int;
				sales_qty_new = NEW.sales_qty::int;
            WHEN 'INSERT'
                THEN data_row = NEW; data_str = NEW::text;
				good_id_new   = NEW.good_id::int;
				sales_qty_new = NEW.sales_qty::int;
        END CASE;
    END IF;
	
    -- Вывод проверки 
    RAISE NOTICE E'\nG_TABLE_NAME = %\nTG_WHEN = %\nTG_OP = %\nTG_LEVEL = %\ndata_str: %\ngood_id_old: %\nsales_qty_old: %\ngood_id_new: %\nsales_qty_new: %\n -------------', TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, data_str, good_id_old, sales_qty_old, good_id_new, sales_qty_new;
     

	if ((SELECT count(*) FROM (SELECT 1 FROM good_sum_mart LIMIT 1) AS t) != 0) then
		-- Если есть новые данные идет добавлять 
		IF (good_id_new != 0) THEN
	        -- Делаю запросы чтобы получить переменные для вычисления.
			SELECT good_name INTO good_name_R FROM good_sum_mart WHERE EXISTS (SELECT * FROM goods WHERE (goods.goods_id = good_id_new) and (good_sum_mart.good_name = goods.good_name));
			SELECT sum_sale INTO sum_sale_R FROM good_sum_mart WHERE EXISTS (SELECT * FROM goods WHERE (goods.goods_id = good_id_new) and (good_sum_mart.good_name = goods.good_name));	
			SELECT good_price INTO good_price_R FROM goods WHERE goods.goods_id = good_id_new;
	        -- Непосредственно сами вычисления, добавляем сумму товаров:
			sum_sale_R = sum_sale_R + (good_price_R * sales_qty_new);
	        -- Перезаписываем полученные значения в таблице good_sum_mart:
			UPDATE good_sum_mart SET sum_sale = sum_sale_R WHERE good_name = good_name_R;
	
		END IF;
	    -- Если есть новые данные или изменённые идем удалять.  
		IF (good_id_old != 0) THEN
	        -- Делаю запросы чтобы получить переменные для вычисления.
			SELECT good_name INTO good_name_R FROM good_sum_mart WHERE EXISTS (SELECT * FROM goods WHERE (goods.goods_id = good_id_old) and (good_sum_mart.good_name = goods.good_name));
			SELECT sum_sale INTO sum_sale_R FROM good_sum_mart WHERE EXISTS (SELECT * FROM goods WHERE (goods.goods_id = good_id_old) and (good_sum_mart.good_name = goods.good_name));	
			SELECT good_price INTO good_price_R FROM goods WHERE goods.goods_id = good_id_old;
	        -- Непосредственно сами вычисления, удаляем сумму товаров:
			sum_sale_R = sum_sale_R - (good_price_R * sales_qty_old);
	        -- Перезаписываем полученные значения в таблице good_sum_mart:
			UPDATE good_sum_mart SET sum_sale = sum_sale_R WHERE good_name = good_name_R;
	
		END IF;
	-- Вывод проверки
	RAISE NOTICE 'Новое значение: %', sum_sale_R;

	ELSE
	        -- Записываю результат запроса с объединением таблиц goods и sales в таблицу good_sum_mart.
	        INSERT INTO good_sum_mart (good_name, sum_sale) 
	        SELECT G.good_name, sum(G.good_price * S.sales_qty)
	        FROM goods G
	        INNER JOIN sales S ON S.good_id = G.goods_id
	        GROUP BY G.good_name;

	END IF;      

    RETURN data_row;		

END;
$$  LANGUAGE plpgsql

# Не посредственно создание триггера на операции с таблицей "sales"  
    CREATE TRIGGER check_sales_trigger
    AFTER INSERT OR UPDATE OR DELETE
    ON "sales"
    FOR EACH ROW
    EXECUTE PROCEDURE check_sales();


# Начальные значения. 
select * from good_sum_mart;
# Картинка с выполненными командами (Картинка ниже!):
```
![Было>](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema11/picture/start_data.jpg "Было")
```bash

# Добавил данные 
INSERT INTO sales (good_id, sales_qty) VALUES (1, 6);
# Картинка с выполненными командами (Картинка ниже!):
```
![Добавил данные](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema11/picture/add_data.jpg "Добавил данные")
```bash

# Изменил данные 
UPDATE sales SET sales_qty = 8 WHERE sales_qty = 6;
# Картинка с выполненными командами (Картинка ниже!):
```
![Изменил данные](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema11/picture/edit_data.jpg "Изменил данные")
```bash

# Удалил данные 
DELETE FROM sales WHERE sales_qty = 8;
# Картинка с выполненными командами (Картинка ниже!):
```
![Удалил данные](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema11/picture/del_data.jpg "Удалил данные")


##
#
# Задание со звездочкой*
# Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
# Подсказка: В реальной жизни возможны изменения цен.

На мой взгляд данная таблица - витрина предпочтительная по нескольким критериям:
1. - Это оперативность получения результата, т.к. не нужно производить полный пересчет по группе таблиц
В таблицах может быть огромное чисто записей. 
2. - Достоверность значений, т.к. при изменении цены мы потеряем информацию о ранее выполненных продажах, а для бизнеса важно знать эту информацию для планирования.
3. - Это экономия ресурсов серверного оборудования на пересчет большого объема данных.   

#
# Маленьки вопрос если не против.
### Созданные талбицы были в схеме pract_functions и приходилось открывать новый редактро скриптов SQL для этой схемы.
### Приписка названия схемы не помогала, но вроде как команда - SET search_path = pract_functions, publ; должна была позвонить видить таблицы схемы. 
### Что я уапустил?
###
#



        




