
# Практика №11 "Секционирование."
# 1. Создать инстанс ВМ с 2 ядрами и 4 Гб ОЗУ и HDD 20GB.

Была создана виртуальная машина:

1. ОС - Ubuntu 24.04 LTS
2. Выделено минимально количество ресурсов
    - CPU 2 
    - RAM 4 ГБ
    - Диск HDD 20 Гб
    - Прерываемая - Да

3. В Дефолтной сети создал подсетку:
    - Имя: otus-vm-db-pg-net-1
    - ip адресация: 10.10.8.0/24
    - Динамический публичный IP адрес

4. Имя VM - otus-db-pg-vm-11

5. Для подключения по SSH воспользовался ранее сгенерированным ключом, во время создания VM указал публичный ключ.

Для подключения использовал  ПО PuTTy, можно так же Powershell и другое ПО.

#

# 2. Установить на него PostgreSQL 15 с дефолтными настройками.
```bash

# https://www.ubuntumint.com/install-postgresql-in-ubuntu/

sudo apt update && sudo apt upgrade -y
# Сначала нужно импортировать ключ PostgreSQL GPG для проверки подлинности установочного пакета:
curl -fSsL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg > /dev/null
# Импортируем стабильный репозиторий PostgreSQL 15, который, как следует из названия, содержит последнюю безопасную, рабочую и стабильную версию
echo deb [arch=amd64,arm64,ppc64el signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main | sudo tee /etc/apt/sources.list.d/postgresql.list
# Теперь нужжно обновить список источников репозитория, чтобы он отражал новые дополнения. Для этого выполним следующую команду:
sudo apt update -y
# Установка PostgreSQL с помощью следующей команды
sudo apt install postgresql-client-15 postgresql-15 -y

# Следующая команда выведет список всех пакетов, связанных с вашей установкой PostgreSQL
dpkg -l | grep postgresql
# Приведенная выше команда выводит список всех системных процессов, использующих/прослушивающих порт 5432
sudo ss -atnp | grep 5432
# Затем перезапустите PostgreSQL, чтобы он продолжал работать даже после перезагрузки системы Ubuntu, и проверьте статус PostgreSQL, чтобы убедиться, что он работает
sudo systemctl restart postgresql
sudo systemctl enable postgresql
sudo systemctl status postgresql

# Проверяем какой кластер запущен
pg_lsclusters
# или
sudo -u postgres pg_lsclusters

Ver Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log

# Картинка с выполненными командами ранее о статусе кластера (Картинка ниже!):
```
![Статус кластера](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema11/picture/status_cluster.jpg "Статус кластера")

#
# Подготовка.
```bash

На основе готовой базы данных примените один из методов секционирования в зависимости от структуры данных.
https://postgrespro.ru/education/demodb

# Скачал базу - demo-small
# Перенес demo-small-20170815.sql в доступное для пользователя postgres места
# И загрузил базу

psql -h localhost -p 5432 -U postgres -f /all_1/demo-small-20170815.sql
# Готво 
\l
                                                List of databases
      Name    |  Owner   | Encoding | Collate |  Ctype  | ICU Locale | Locale Provider |   Access privileges
    -----------+----------+----------+---------+---------+------------+-----------------+-----------------------
    demo      | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            |
    postgres  | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            |
    template0 | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            | =c/postgres          +
              |          |          |         |         |            |                 | postgres=CTc/postgres
    template1 | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            | =c/postgres          +
              |          |          |         |         |            |                 | postgres=CTc/postgres
    (4 rows)

# Переходим в базу:

\c demo
demo=# \dt
                List of relations
     Schema  |      Name       | Type  |  Owner
    ----------+-----------------+-------+----------
    bookings | aircrafts_data  | table | postgres
    bookings | airports_data   | table | postgres
    bookings | boarding_passes | table | postgres
    bookings | bookings        | table | postgres
    bookings | flights         | table | postgres
    bookings | seats           | table | postgres
    bookings | ticket_flights  | table | postgres
    bookings | tickets         | table | postgres
    (8 rows)

```
#
# 3. Анализ структуры данных.
Ознакомьтесь с таблицами базы данных, особенно с таблицами bookings, tickets, ticket_flights, flights, 
boarding_passes, seats, airports, aircrafts.
Определите, какие данные в таблице bookings или других таблицах имеют логическую привязку к диапазонам, по 
которым можно провести секционирование (например, дата бронирования, рейсы).
```bash

# Смотрим что в каждой таблице:

SELECT * FROM aircrafts_data LIMIT 3;
    aircraft_code |                           model                            | range 
    ---------------+------------------------------------------------------------+-------
    773           | {"en": "Boeing 777-300", "ru": "Боинг 777-300"}            | 11100
    763           | {"en": "Boeing 767-300", "ru": "Боинг 767-300"}            |  7900
    SU9           | {"en": "Sukhoi Superjet-100", "ru": "Сухой Суперджет-100"} |  3000
    (3 rows)

SELECT * FROM airports_data LIMIT 3;
airport_code |                        airport_name                        |                  city                   |               coordinates               |     timezone     
--------------+------------------------------------------------------------+-----------------------------------------+-----------------------------------------+----------------
YKS          | {"en": "Yakutsk Airport", "ru": "Якутск"}                  | {"en": "Yakutsk", "ru": "Якутск"}       | (129.77099609375,62.093299865722656)    | Asia/Yakutsk
MJZ          | {"en": "Mirny Airport", "ru": "Мирный"}                    | {"en": "Mirnyj", "ru": "Мирный"}        | (114.03900146484375,62.534698486328125) | Asia/Yakutsk
KHV          | {"en": "Khabarovsk-Novy Airport", "ru": "Хабаровск-Новый"} | {"en": "Khabarovsk", "ru": "Хабаровск"} | (135.18800354004,48.52799987793)        | Asia/Vladivostok
(3 rows)

SELECT * FROM boarding_passes LIMIT 3;
    ticket_no   | flight_id | boarding_no | seat_no 
    ---------------+-----------+-------------+---------
    0005435212351 |     30625 |           1 | 2D      
    0005435212386 |     30625 |           2 | 3G      
    0005435212381 |     30625 |           3 | 4H      
    (3 rows)


SELECT * FROM bookings LIMIT 3;
    book_ref |       book_date        | total_amount 
    ----------+------------------------+--------------
    00000F   | 2017-07-05 00:12:00+00 |    265700.00 
    000012   | 2017-07-14 06:02:00+00 |     37900.00 
    000068   | 2017-08-15 11:27:00+00 |     18100.00 
    (3 rows)


SELECT * FROM flights LIMIT 3;
 flight_id | flight_no |  scheduled_departure   |   scheduled_arrival    | departure_airport | arrival_airport |  status   | aircraft_code | actual_departure | actual_arrival 
-----------+-----------+------------------------+------------------------+-------------------+-----------------+-----------+---------------+------------------+----------------
      1185 | PG0134    | 2017-09-10 06:50:00+00 | 2017-09-10 11:55:00+00 | DME               | BTK             | Scheduled | 319           |                  |
      3979 | PG0052    | 2017-08-25 11:50:00+00 | 2017-08-25 14:35:00+00 | VKO               | HMA             | Scheduled | CR2           |                  |
      4739 | PG0561    | 2017-09-05 09:30:00+00 | 2017-09-05 11:15:00+00 | VKO               | AER             | Scheduled | 763           |                  |
(3 rows)

SELECT * FROM seats LIMIT 3;
 aircraft_code | seat_no | fare_conditions 
---------------+---------+-----------------
 319           | 2A      | Business
 319           | 2C      | Business
 319           | 2D      | Business
(3 rows)

SELECT * FROM ticket_flights LIMIT 3;
   ticket_no   | flight_id | fare_conditions |  amount  
---------------+-----------+-----------------+----------
 0005432159776 |     30625 | Business        | 42100.00
 0005435212351 |     30625 | Business        | 42100.00
 0005435212386 |     30625 | Business        | 42100.00
(3 rows)

SELECT * FROM tickets LIMIT 3;
   ticket_no   | book_ref | passenger_id |   passenger_name   |       contact_data        
---------------+----------+--------------+--------------------+---------------------------
 0005432000987 | 06B046   | 8149 604011  | VALERIY TIKHONOV   | {"phone": "+70127117011"}
 0005432000988 | 06B046   | 8499 420203  | EVGENIYA ALEKSEEVA | {"phone": "+70378089255"}
 0005432000989 | E170C3   | 1011 752484  | ARTUR GERASIMOV    | {"phone": "+70760429203"}
(3 rows)

# Вышло конечно скучно, нужно было в цикле, но не стал тратить время. (Как админ с базами так близко не работал)
# Для прома такой арендой заниматься не стоит.

# Для секционирования по диапазону хорошо подходят таблицы:
# - bookings по полю book_date
# - flights по полю scheduled_departure или scheduled_arrival
# - ticket_flights по полю amount

# Очень подходить для секционирования по списку таблицы:
# - airports_data, поле city 
# - seats, поле fare_conditions 
# - ticket_flights по полю fare_conditions

# Словом вариантов может быть огромное множество.
# Все зависит от заказчика, какие запросы выполняются чаще и какая таблица (объем)

```
#
# 4. Выбор таблицы для секционирования.
Основной акцент делается на секционировании таблицы bookings. 
Но вы можете выбрать и другие таблицы, если видите в этом смысл для оптимизации производительности (например, flights, boarding_passes).
Обоснуйте свой выбор: почему именно эта таблица требует секционирования? Какой тип данных является ключевым для секционирования?
```bash

# Для секционирования по диапазону выбрал 
# bookings по полю book_date

SELECT count(*) FROM bookings;
    count  
    --------
    262788 
    (1 row) 
# А данную таблицу решил оставить по умолчанию для работы.

# Для секционирования по списку взял таблицу ticket_flights.
SELECT count(*) FROM ticket_flights;
    count  
    ---------
    1045726 
    (1 row)

# Быстрый поиск билетов на рейс думаю важная задача.
# И учитывая что на не большой базе уже имеет один миллион записей.
# Думаю что хорошо бы разделить по типу билетов.

```
#
# 5. Определение типа секционирования:
Определитесь с типом секционирования, которое наилучшим образом подходит для ваших данных:

- По диапазону (например, по дате бронирования или дате рейса).
- По списку (например, по пунктам отправления или по номерам рейсов).
- По хэшированию (для равномерного распределения данных).

```bash

# Для таблицы bookings как я понял это дата бронирования.
# Можно разделить на секции по одному месяцу.

SELECT min(book_date), max(book_date) FROM bookings;
          min           |          max
------------------------+------------------------
 2017-06-21 11:05:00+00 | 2017-08-15 15:00:00+00 
(1 row)
# Разделять будем по ДИАПАЗОНУ.

# В таблице поле подходящее для fare_conditions

SELECT DISTINCT fare_conditions FROM ticket_flights;
    fare_conditions 
    -----------------
    Business        
    Comfort
    Economy
(3 rows)

# Разделение будет по списку, поле fare_conditions (условия оплаты проезда).

```
#
# 6. Создание секционированной таблицы:
Преобразуйте таблицу в секционированную с выбранным типом секционирования.
Например, если вы выбрали секционирование по диапазону дат бронирования, создайте секции по месяцам или годам.
```bash


#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Создаю отдельную схему как и учили:

DROP TABLE IF EXISTS air_copy.bookings CASCADE;

demo=# CREATE SCHEMA air_copy;
CREATE SCHEMA


# Анализ данных таблицы bookings:

\d bookings;
                            Table "bookings.bookings"
       Column    |           Type           | Collation | Nullable | Default
    --------------+--------------------------+-----------+----------+---------
    book_ref     | character(6)             |           | not null |
    book_date    | timestamp with time zone |           | not null |
    total_amount | numeric(10,2)            |           | not null |
    Indexes:
        "bookings_pkey" PRIMARY KEY, btree (book_ref)
    Referenced by:
        TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)

# Создаем копию таблицы bookings только с ранее созданной схеме: 

CREATE TABLE air_copy.bookings
(
    book_ref        character(6)             NOT NULL,
    book_date       timestamp with time zone NOT NULL,
    total_amount    numeric(10,2)            NOT NULL,
    
    PRIMARY KEY (book_ref, book_date)
) PARTITION BY RANGE (book_date);

# Определяю какие значения уже есть и их минимальное и максимальное значение:

SELECT min(book_date), max(book_date) FROM bookings;
          min           |          max
------------------------+------------------------
 2017-06-21 11:05:00+00 | 2017-08-15 15:00:00+00 
(1 row) 

# Создаю секции:

CREATE TABLE air_copy.bookings_2017_1 PARTITION OF air_copy.bookings FOR VALUES FROM ('2017-06-01') TO ('2017-07-01');
CREATE TABLE air_copy.bookings_2017_2 PARTITION OF air_copy.bookings FOR VALUES FROM ('2017-07-01') TO ('2017-08-01');
CREATE TABLE air_copy.bookings_2017_3 PARTITION OF air_copy.bookings FOR VALUES FROM ('2017-08-01') TO ('2017-09-01');

# Создаю секцию для данных которые не попадают в ранее созданные секции:

CREATE TABLE air_copy.bookings_other PARTITION OF air_copy.bookings DEFAULT;


#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Работы с таблицей ticket_flights
# Анализ данных таблицы ticket_flights:

\d ticket_flights;
                     Table "bookings.ticket_flights"
     Column      |         Type          | Collation | Nullable | Default
-----------------+-----------------------+-----------+----------+---------
 ticket_no       | character(13)         |           | not null |
 flight_id       | integer               |           | not null |
 fare_conditions | character varying(10) |           | not null |
 amount          | numeric(10,2)         |           | not null |
Indexes:
    "ticket_flights_pkey" PRIMARY KEY, btree (ticket_no, flight_id)
Check constraints:
    "ticket_flights_amount_check" CHECK (amount >= 0::numeric)
    "ticket_flights_fare_conditions_check" CHECK (fare_conditions::text = ANY (ARRAY['Economy'::character varying::text, 'Comfort'::character varying::text, 'Business'::character varying::text]))
Foreign-key constraints:
    "ticket_flights_flight_id_fkey" FOREIGN KEY (flight_id) REFERENCES flights(flight_id)
    "ticket_flights_ticket_no_fkey" FOREIGN KEY (ticket_no) REFERENCES tickets(ticket_no)
Referenced by:
    TABLE "boarding_passes" CONSTRAINT "boarding_passes_ticket_no_fkey" FOREIGN KEY (ticket_no, flight_id) REFERENCES ticket_flights(ticket_no, flight_id)


# Создаем копию таблицы bookings только с ранее созданной схеме: 

CREATE TABLE air_copy.ticket_flights
(
    ticket_no        character(13)            NOT NULL,
    flight_id        integer                  NOT NULL,
    fare_conditions  character varying(10)    NOT NULL,
    amount           numeric(10,2)            NOT NULL,

    PRIMARY KEY (ticket_no, flight_id, fare_conditions)
) PARTITION BY LIST (fare_conditions);

# Определяю какие вообще есть значения в базе в поле fare_conditions:

SELECT DISTINCT fare_conditions FROM ticket_flights;
    fare_conditions 
    -----------------
    Business        
    Comfort
    Economy
(3 rows)

CREATE TABLE air_copy.ticket_flights_00 PARTITION OF air_copy.ticket_flights FOR VALUES IN ('Business');
CREATE TABLE air_copy.ticket_flights_01 PARTITION OF air_copy.ticket_flights FOR VALUES IN ('Comfort');
CREATE TABLE air_copy.ticket_flights_02 PARTITION OF air_copy.ticket_flights FOR VALUES IN ('Economy');

# Создаю секцию для данных которые не попадают в ранее созданные секции:

CREATE TABLE air_copy.ticket_flights_other PARTITION OF air_copy.ticket_flights DEFAULT;

```
#
# 7. Миграция данных:
Перенесите существующие данные из исходной таблицы в секционированную структуру.
Убедитесь, что все данные правильно распределены по секциям.
```bash

#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Запускаю копирование данных из исходной таблицы bookings.bookings в новую air_copy.bookings:

INSERT INTO air_copy.bookings
OVERRIDING SYSTEM VALUE
SELECT * FROM bookings.bookings;

# INSERT 0 262788

SELECT * FROM bookings.bookings LIMIT 10;
    book_ref |       book_date        | total_amount 
    ----------+------------------------+--------------
    00000F   | 2017-07-05 00:12:00+00 |    265700.00 
    000012   | 2017-07-14 06:02:00+00 |     37900.00 
    000068   | 2017-08-15 11:27:00+00 |     18100.00 
    000181   | 2017-08-10 10:28:00+00 |    131800.00 
    0002D8   | 2017-08-07 18:40:00+00 |     23600.00
    0002DB   | 2017-07-29 03:30:00+00 |    101500.00
    0002E0   | 2017-07-11 13:09:00+00 |     89600.00
    0002F3   | 2017-07-10 02:31:00+00 |     69600.00
    00034E   | 2017-08-04 13:52:00+00 |     73300.00
    000352   | 2017-07-05 23:02:00+00 |    109500.00
    (10 rows)


SELECT * FROM air_copy.bookings LIMIT 10;
    book_ref |       book_date        | total_amount 
    ----------+------------------------+--------------
    000B77   | 2017-06-30 23:39:00+00 |     68800.00
    0026F8   | 2017-06-25 18:15:00+00 |     58200.00
    0029F9   | 2017-06-29 22:45:00+00 |     58600.00
    004DF7   | 2017-06-30 02:12:00+00 |     72300.00
    005558   | 2017-06-27 00:02:00+00 |     28000.00
    0057F8   | 2017-06-28 11:33:00+00 |     20200.00
    0070F5   | 2017-06-30 19:05:00+00 |     62600.00
    0087C1   | 2017-06-26 10:43:00+00 |     28000.00
    008822   | 2017-06-29 18:33:00+00 |     64500.00
    008A31   | 2017-06-28 09:12:00+00 |     56000.00
    (10 rows)

# Данные есть, только последовательность записи в таблицу изменилась.

SELECT count(*) FROM bookings.bookings;
    count  
    --------
    262788
    (1 row)

SELECT count(*) FROM air_copy.bookings;
    count  
    --------
    262788
    (1 row)

# Общее количество полей совпадает.

demo=# SELECT * FROM bookings.bookings
demo-#     WHERE book_ref = '00000F';
 book_ref |       book_date        | total_amount 
----------+------------------------+--------------
 00000F   | 2017-07-05 00:12:00+00 |    265700.00
(1 row)

demo=# SELECT * FROM air_copy.bookings
demo-#     WHERE book_ref = '00000F';
 book_ref |       book_date        | total_amount 
----------+------------------------+--------------
 00000F   | 2017-07-05 00:12:00+00 |    265700.00
(1 row)

# Данные тоже есть, для теста запросил одно полей из разных таблиц.
# Конечно можно проверить в цикле каждое из одной таблице в другой, но в этом нет смысла. 

#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Запускаю копирование данных из исходной таблицы bookings.ticket_flights в новую air_copy.ticket_flights:

INSERT INTO air_copy.ticket_flights
OVERRIDING SYSTEM VALUE
SELECT * FROM bookings.ticket_flights;

# INSERT 0 1045726

SELECT * FROM bookings.ticket_flights LIMIT 10;
      ticket_no   | flight_id | fare_conditions |  amount  
    ---------------+-----------+-----------------+----------
    0005432329942 |     21062 | Economy         |  6300.00
    0005432384329 |     21062 | Economy         |  6300.00
    0005432330013 |     21062 | Economy         |  6300.00
    0005432384338 |     21062 | Economy         |  6300.00
    0005432425917 |     30812 | Business        | 12700.00
    0005432426024 |     30812 | Business        | 12700.00
    0005432425994 |     30812 | Business        | 12700.00
    0005432426032 |     30812 | Business        | 12700.00
    0005432425912 |     30812 | Business        | 12700.00
    0005432425949 |     30812 | Business        | 12700.00
    (10 rows)

SELECT * FROM air_copy.ticket_flights LIMIT 10;
      ticket_no   | flight_id | fare_conditions |  amount  
    ---------------+-----------+-----------------+----------
    0005432425917 |     30812 | Business        | 12700.00
    0005432426024 |     30812 | Business        | 12700.00
    0005432425994 |     30812 | Business        | 12700.00
    0005432426032 |     30812 | Business        | 12700.00
    0005432425912 |     30812 | Business        | 12700.00
    0005432425949 |     30812 | Business        | 12700.00
    0005432426078 |     30812 | Business        | 12700.00
    0005432902109 |      9597 | Business        | 32600.00
    0005432818291 |     28988 | Business        | 32600.00
    0005432818241 |     28988 | Business        | 32600.00
    (10 rows)

# Данные есть, но тоже в другом порядке.

demo=# SELECT count(*) FROM bookings.ticket_flights;
    count  
    ---------
    1045726
    (1 row)

demo=# SELECT count(*) FROM air_copy.ticket_flights;
    count  
    ---------
    1045726
    (1 row)

# Так же общее количество полей совпадает.

demo=# SELECT * FROM bookings.ticket_flights
demo-#      WHERE ticket_no = '0005432329942';
      ticket_no   | flight_id | fare_conditions | amount  
    ---------------+-----------+-----------------+---------
    0005432329942 |      3089 | Economy         | 5400.00
    0005432329942 |     21062 | Economy         | 6300.00
    0005432329942 |     31098 | Economy         | 5400.00
    0005432329942 |     31268 | Economy         | 6300.00
(4 rows)

SELECT * FROM air_copy.ticket_flights
     WHERE ticket_no = '0005432329942';
      ticket_no   | flight_id | fare_conditions | amount  
    ---------------+-----------+-----------------+---------
    0005432329942 |     21062 | Economy         | 6300.00
    0005432329942 |      3089 | Economy         | 5400.00
    0005432329942 |     31268 | Economy         | 6300.00
    0005432329942 |     31098 | Economy         | 5400.00
    (4 rows)
    
# Все есть в каждой таблице.

```
#
# 8. Оптимизация запросов:
Проверьте, как секционирование влияет на производительность запросов. Выполните несколько выборок данных до и после секционирования для оценки времени выполнения.
Оптимизируйте запросы при необходимости (например, добавьте индексы на ключевые столбцы).
```bash

#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Работа с первой таблицей. (разбитой по диапазонам)

# Запрос к исходной таблице - bookings.bookings:

EXPLAIN ANALYZE
SELECT * FROM bookings.bookings WHERE book_date BETWEEN '2017-07-01' AND '2017-07-10';
                                                                     QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Seq Scan on bookings  (cost=0.00..5615.82 rows=44393 width=21) (actual time=0.009..20.217 rows=45429 loops=1)
   Filter: ((book_date >= '2017-07-01 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+00'::timestamp with time zone))
   Rows Removed by Filter: 217359
 Planning Time: 0.054 ms
 Execution Time: 21.749 ms
(5 rows)

# Запрос к новой таблице air_copy.bookings с секциями:

EXPLAIN ANALYZE
SELECT * FROM air_copy.bookings WHERE book_date BETWEEN '2017-07-01' AND '2017-07-10';
                                                                     QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------   
 Seq Scan on bookings_2017_2 bookings  (cost=0.00..3575.02 rows=45393 width=21) (actual time=0.016..19.452 rows=45429 loops=1)
   Filter: ((book_date >= '2017-07-01 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+00'::timestamp with time zone))    
   Rows Removed by Filter: 121839
 Planning Time: 12.454 ms
 Execution Time: 21.075 ms
(5 rows)

# Не сказать что фатально быстрее, но чуть быстрее:
# было - Execution Time: 21.749 ms стало -  Execution Time: 21.075 ms
# И вероятность что поиск завершиться быстрее шансов стало больгы на 1/4 примерно. (было cost=0.00..5615.82 стало - cost=0.00..3575.02).
# И план работ запроса уже не по всей таблице делает Seq Scan, а только по одной секции.! 


# Создаем простые индексы для bookings.bookings - book_date:

CREATE INDEX
    idx_bookings_bookings_book_date
    ON bookings.bookings(book_date);

# Создаем простые индексы для air_copy.bookings - book_date:

CREATE INDEX
    idx_air_copy_bookings_book_date
    ON air_copy.bookings(book_date);

# Повторяем запрос к исходной таблице - bookings.bookings:

EXPLAIN ANALYZE
SELECT * FROM bookings.bookings WHERE book_date BETWEEN '2017-07-01' AND '2017-07-10';
                                                                          QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on bookings  (cost=747.45..3087.35 rows=44393 width=21) (actual time=4.423..17.219 rows=45429 loops=1)
   Recheck Cond: ((book_date >= '2017-07-01 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+00'::timestamp with time zone))     
   Heap Blocks: exact=1674
   ->  Bitmap Index Scan on idx_bookings_bookings_book_date  (cost=0.00..736.35 rows=44393 width=0) (actual time=4.127..4.127 rows=45429 loops=1)
         Index Cond: ((book_date >= '2017-07-01 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+00'::timestamp with time zone))       
 Planning Time: 0.228 ms
 Execution Time: 20.203 ms
(7 rows)

# Повторяем запрос к новой таблице air_copy.bookings с секциями:

EXPLAIN ANALYZE
SELECT * FROM air_copy.bookings WHERE book_date BETWEEN '2017-07-01' AND '2017-07-10';
                                                                          QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------------------------      
 Bitmap Heap Scan on bookings_2017_2 bookings  (cost=761.75..2508.90 rows=45410 width=21) (actual time=2.449..8.807 rows=45429 loops=1)
   Recheck Cond: ((book_date >= '2017-07-01 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+00'::timestamp with time zone))
   Heap Blocks: exact=1066
   ->  Bitmap Index Scan on bookings_2017_2_book_date_idx  (cost=0.00..750.39 rows=45410 width=0) (actual time=2.276..2.277 rows=45429 loops=1)
         Index Cond: ((book_date >= '2017-07-01 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+00'::timestamp with time zone))       
 Planning Time: 0.285 ms
 Execution Time: 10.273 ms

# Тут разница просто фантастическая по времени выполнения, в два раза быстрее поиск по таблице с секциями. 
# (исходная  Execution Time: 20.203 ms - новая  Execution Time: 10.273 ms таблица)


#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Работа с второй таблицей. (разбитой по списку)

# Запрос к исходной таблице - bookings.ticket_flights:

EXPLAIN ANALYZE
SELECT * FROM bookings.ticket_flights WHERE fare_conditions = 'Comfort' LIMIT 2;
                                                      QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..2.50 rows=2 width=32) (actual time=0.222..0.224 rows=2 loops=1)
   ->  Seq Scan on ticket_flights  (cost=0.00..21786.58 rows=17429 width=32) (actual time=0.221..0.222 rows=2 loops=1) 
         Filter: ((fare_conditions)::text = 'Comfort'::text)
         Rows Removed by Filter: 1161
 Planning Time: 0.072 ms
 Execution Time: 0.239 ms
(6 rows)

# Запрос к новой таблице air_copy.ticket_flights с секциями:

EXPLAIN ANALYZE
SELECT * FROM air_copy.ticket_flights WHERE fare_conditions = 'Comfort' LIMIT 2;
                                                             QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.04 rows=2 width=33) (actual time=0.028..0.029 rows=2 loops=1)
   ->  Seq Scan on ticket_flights_01 ticket_flights  (cost=0.00..361.14 rows=17291 width=33) (actual time=0.027..0.027 rows=2 loops=1) 
         Filter: ((fare_conditions)::text = 'Comfort'::text)
 Planning Time: 0.090 ms
 Execution Time: 0.040 ms
(5 rows)

# Как-то не пошло даже стало несколько хуже.
# было -  Execution Time: 0.239 ms - стало - Execution Time: 0.040 ms (время выполнения)
# Хотя показывает что максимально возможная стоимость ниже.

# Запрос к исходной таблице - bookings.ticket_flights с более сложными условиями:

EXPLAIN ANALYZE
SELECT * FROM bookings.ticket_flights
WHERE fare_conditions = 'Comfort'
      AND ticket_no = '0005434876621';
                                                              QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using ticket_flights_pkey on ticket_flights  (cost=0.42..16.47 rows=1 width=32) (actual time=0.021..0.028 rows=1 loops=1) 
   Index Cond: (ticket_no = '0005434876621'::bpchar)
   Filter: ((fare_conditions)::text = 'Comfort'::text)
   Rows Removed by Filter: 3
 Planning Time: 0.063 ms
 Execution Time: 0.040 ms
(6 rows)

# Запрос к новой таблице с секциями air_copy.ticket_flights с более сложными условиями:

EXPLAIN ANALYZE
SELECT * FROM air_copy.ticket_flights
WHERE fare_conditions = 'Comfort'
      AND ticket_no = '0005434876621';
                                                                        QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using ticket_flights_01_pkey on ticket_flights_01 ticket_flights  (cost=0.29..8.31 rows=1 width=33) (actual time=0.032..0.034 rows=1 loops=1)
   Index Cond: ((ticket_no = '0005434876621'::bpchar) AND ((fare_conditions)::text = 'Comfort'::text))
 Planning Time: 0.096 ms
 Execution Time: 0.045 ms
(4 rows)

# При более сложном запросе ситуация по времени поиска стало почти равной.

# Пробуем проверить запросы с индексами.
# Создаем простые индексы для bookings.bookings - ticket_no:

CREATE INDEX 
    ix_bookings_ticket_flights_ticket_no
    ON bookings.ticket_flights USING btree (ticket_no);

# Создаем простые индексы для air_copy.ticket_flights - ticket_no:

CREATE INDEX 
    ix_air_copy_ticket_flights_ticket_no
    ON air_copy.ticket_flights USING btree (ticket_no);

# Работа с базовой таблицей. (без секций):

EXPLAIN ANALYZE
SELECT * FROM bookings.ticket_flights
WHERE fare_conditions = 'Comfort'
      AND ticket_no = '0005434876621';
                                                                      QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using ix_bookings_ticket_flights_ticket_no on ticket_flights  (cost=0.42..16.46 rows=1 width=32) (actual time=0.026..0.030 rows=1 loops=1)
   Index Cond: (ticket_no = '0005434876621'::bpchar)
   Filter: ((fare_conditions)::text = 'Comfort'::text)
   Rows Removed by Filter: 3
 Planning Time: 0.094 ms
 Execution Time: 0.047 ms
(6 rows)

# Работа с второй таблицей. (разбитой по секциям):

EXPLAIN ANALYZE
SELECT * FROM air_copy.ticket_flights
WHERE fare_conditions = 'Comfort'
      AND ticket_no = '0005434876621';
                                                                            QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using ticket_flights_01_ticket_no_idx on ticket_flights_01 ticket_flights  (cost=0.29..8.31 rows=1 width=33) (actual time=0.018..0.019 rows=1 loops=1)
   Index Cond: (ticket_no = '0005434876621'::bpchar)
   Filter: ((fare_conditions)::text = 'Comfort'::text)
 Planning Time: 0.102 ms
 Execution Time: 0.032 ms
(5 rows)

# С индексами время выполнения запроса стала заметно лучше у таблицы с секциями.

```
#
# 9. Тестирование решения:
Протестируйте секционирование, выполняя несколько запросов к секционированной таблице.
Проверьте, что операции вставки, обновления и удаления работают корректно.
```bash

SELECT * FROM air_copy.ticket_flights

# Записываю данные в таблицу air_copy.bookings (с секциями):

INSERT INTO air_copy.bookings
    (book_ref,book_date, total_amount)
    VALUES ('000018','2017-07-06 00:12:00+00' ,'45844');

# Проверяю что они там есть:

SELECT * FROM air_copy.bookings
    WHERE book_date BETWEEN '2017-07-06' AND '2017-07-07'
    AND   book_ref = '000018';

     book_ref |       book_date        | total_amount 
    ----------+------------------------+--------------
     000018   | 2017-07-06 00:12:00+00 |     45844.00
     (1 row)

# Проверяю какой план работы запроса:

EXPLAIN ANALYZE
SELECT * FROM air_copy.bookings
    WHERE book_date BETWEEN '2017-07-06' AND '2017-07-06';
    AND   book_ref = '000018';
                                                                          QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------------------------        
 Bitmap Heap Scan on bookings_2017_2 bookings  (cost=4.34..19.66 rows=4 width=21) (actual time=0.017..0.021 rows=4 loops=1)
   Recheck Cond: ((book_date >= '2017-07-06 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-06 00:00:00+00'::timestamp with time zone))
   Heap Blocks: exact=4
   ->  Bitmap Index Scan on bookings_2017_2_book_date_idx  (cost=0.00..4.33 rows=4 width=0) (actual time=0.011..0.011 rows=4 loops=1)
         Index Cond: ((book_date >= '2017-07-06 00:00:00+00'::timestamp with time zone) AND (book_date <= '2017-07-06 00:00:00+00'::timestamp with time zone))
 Planning Time: 0.097 ms
 Execution Time: 0.037 ms

(7 rows)
# По плану работ запроса видно, что данные записались в секцию bookings_2017_2, что правильно.
# И анализ индексов идет сразу в данной таблице, для определения на какой дисковой странице искать данные.
# И далее поиск. 
# Все работает правильно.!

# Пробую изменить ранее внесенные данные:

UPDATE air_copy.bookings 
    SET   total_amount = (total_amount  + 100)
    WHERE book_date BETWEEN '2017-07-06' AND '2017-07-07';

SELECT * FROM air_copy.bookings
    WHERE book_date BETWEEN '2017-07-06' AND '2017-07-07'
    AND   book_ref = '000018';

     book_ref |       book_date        | total_amount 
    ----------+------------------------+--------------
     000018   | 2017-07-06 00:12:00+00 |     45944.00
     (1 row)

# Видно что данные успешно было изменены.

# Пробую удалить ранее добавленные данные:

DELETE FROM air_copy.bookings  
    WHERE book_date BETWEEN '2017-07-06' AND '2017-07-07'
    AND   book_ref = '000018';

SELECT * FROM air_copy.bookings
    WHERE book_date BETWEEN '2017-07-06' AND '2017-07-07'
    AND   book_ref = '000018';

     book_ref | book_date | total_amount 
    ----------+-----------+--------------
    (0 rows)

# Видно данные удалились.

#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Работа с второй таблицей. (разбитой по списку)

# Записываю данные в таблицу air_copy.ticket_flights (с секциями):

INSERT INTO air_copy.ticket_flights
    (ticket_no, flight_id, fare_conditions, amount)
    VALUES ('0005432949578', 11673 , 'Business', '108670');

# Проверяю что они там есть:

SELECT * FROM air_copy.ticket_flights
    WHERE fare_conditions = 'Business'
    AND   amount = 108670;

       ticket_no   | flight_id | fare_conditions |  amount   
    ---------------+-----------+-----------------+-----------
     0005432949578 |     11673 | Business        | 108670.00
    (1 row)

# Данные записались.

# Смотрим план работ запроса:

EXPLAIN ANALYZE
SELECT * FROM air_copy.ticket_flights
    WHERE fare_conditions = 'Business'
    AND   amount = 108670;
                                                           QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Seq Scan on ticket_flights_00 ticket_flights  (cost=0.00..2512.63 rows=33 width=33) (actual time=14.661..14.662 rows=1 loops=1)
   Filter: (((fare_conditions)::text = 'Business'::text) AND (amount = '108670'::numeric))
   Rows Removed by Filter: 107642
 Planning Time: 0.103 ms
 Execution Time: 14.674 ms
(5 rows)    

# Все правильно, т.к. Business у нас в секции ticket_flights_00.


# Пробую изменить ранее внесенные данные:

UPDATE air_copy.ticket_flights 
    SET   amount = (amount  + 1000)
    WHERE fare_conditions = 'Business'
    AND   amount = 108670;

SELECT * FROM air_copy.ticket_flights
    WHERE fare_conditions = 'Business'
    AND   amount = 109670;

       ticket_no   | flight_id | fare_conditions |  amount   
    ---------------+-----------+-----------------+-----------
     0005432949578 |     11673 | Business        | 109670.00
    (1 row)
```
Видно что данные успешно были изменены.

Пробую удалить ранее добавленные данные:
```bash
DELETE FROM air_copy.ticket_flights   
    WHERE fare_conditions = 'Business'
    AND   amount = 109670;

SELECT * FROM air_copy.ticket_flights
    WHERE fare_conditions = 'Business'
    AND   amount = 109670;

     ticket_no | flight_id | fare_conditions | amount 
    -----------+-----------+-----------------+--------
    (0 rows)
```
Видно данные удалились!

```bash

```
#
# 10. Документирование:
Добавьте комментарии к коду, поясняющие выбранный тип секционирования и шаги его реализации.
Опишите, как секционирование улучшает производительность запросов и как оно может быть полезно в реальных условиях.


Комментариев к коду оставил выше думаю достаточно!

Секционирование таблиц несколько плюсов:
- Производительность
    Запросы выполняются быстрее, особенно есть использовать индексы, что и продемонстрировал выше.
- Управление данными
    Данные можно хранить в разных места физически на диске. Удалений старых данных, а точнее секции простая задача.
- Резервное копирование
    При работе с данными даже если и идет блокировка таблицы, то не всей, а только секции.
- Масштабируемость
    Эффективная обработка больших объёмов данных.

Все перечисленные тезисы справедливы, но нужно каждая задача уникальная и все зависит от специфики работы заказчик.
Как показано выше секционирование можно настроить позже, но лучше его учитывать в момент проектирования.
```bash
# И при создании заметно наверно не сильно верная работы у меня с ключами таблиц.
# В созданных мной таблицах нет связей с другими таблицами. Хотя по командам 
# \d bookings.ticket_flights \d bookings.bookings их видно.
# Очень надеюсь что далее в курсе об это расскажут.

```
#