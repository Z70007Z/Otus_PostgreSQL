
# Практика №10 "Виды индексов. Работа с индексами и оптимизация запросов."
# 1. Создать инстанс ВМ с 2 ядрами и 4 Гб ОЗУ и HDD 20GB.

Была создана виртуальная машина:

1. ОС - Ubuntu 24.04 LTS
2. Выделено минимально количество ресурсов
    - CPU 2 
    - RAM 4 ГБ
    - Диск HDD 20 Гб
    - Прерываемая - Да

3. В Дефолтной сети создал подсетку:
    - Имя: otus-vm-db-pg-net-1
    - ip адресация: 10.10.8.0/24
    - Динамический публичный IP адрес

4. Имя VM - otus-db-pg-vm-10

5. Для подключения по SSH воспользовался ранее сгенерированным ключом, во время создания VM указал публичный ключ.

Для подключения использовал  ПО PuTTy, можно так же Powershell и другое ПО.

#

# 2. Установить на него PostgreSQL 15 с дефолтными настройками.
```bash

# https://www.ubuntumint.com/install-postgresql-in-ubuntu/

sudo apt update && sudo apt upgrade -y
# Сначала нужно импортировать ключ PostgreSQL GPG для проверки подлинности установочного пакета:
curl -fSsL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg > /dev/null
# Импортируем стабильный репозиторий PostgreSQL 15, который, как следует из названия, содержит последнюю безопасную, рабочую и стабильную версию
echo deb [arch=amd64,arm64,ppc64el signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main | sudo tee /etc/apt/sources.list.d/postgresql.list
# Теперь нужжно обновить список источников репозитория, чтобы он отражал новые дополнения. Для этого выполним следующую команду:
sudo apt update -y
# Установка PostgreSQL с помощью следующей команды
sudo apt install postgresql-client-15 postgresql-15 -y

# Следующая команда выведет список всех пакетов, связанных с вашей установкой PostgreSQL
dpkg -l | grep postgresql
# Приведенная выше команда выводит список всех системных процессов, использующих/прослушивающих порт 5432
sudo ss -atnp | grep 5432
# Затем перезапустите PostgreSQL, чтобы он продолжал работать даже после перезагрузки системы Ubuntu, и проверьте статус PostgreSQL, чтобы убедиться, что он работает
sudo systemctl restart postgresql
sudo systemctl enable postgresql
sudo systemctl status postgresql

# Проверяем какой кластер запущен
pg_lsclusters
# или
sudo -u postgres pg_lsclusters

Ver Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log

# Картинка с выполненными командами ранее о статусе кластера (Картинка ниже!):
```
![Статус кластера](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema10/picture/status_cluster.jpg "Статус кластера")

#

# 3. Создать индекс к какой-либо из таблиц вашей БД.
```bash

# Создаем новю базу для работы:
postgres=# CREATE DATABASE student_indexes;
CREATE DATABASE

# Переходим в базу
\c student_indexes

\pset null [NULL]

# Создаем таблицу
CREATE TABLE products(
    product_id   integer,
    brand        char(1),
    gender       char(1),
    price        integer,
    is_available boolean
);

# Генерируем данные случайным образом 
WITH random_data AS (
    SELECT
    num,
    random() AS rand1,
    random() AS rand2,
    random() AS rand3
    FROM generate_series(1,100000) AS s(num)
)
INSERT INTO products
    (product_id, brand, gender, price, is_available)
SELECT
    random_data.num,
    chr((32 + random_data.rand1 * 94)::integer),
    case when random_data.num % 2 = 0 then 'М' else 'Ж' end,
    (random_data.rand2 * 100)::integer,
    random_data.rand3 < 0.01
    FROM random_data
    ORDER BY random();   

# Проверяем что что-то да есть в таблице:
student_indexes=# SELECT * FROM products LIMIT 10;
 product_id | brand | gender | price | is_available 
------------+-------+--------+-------+--------------
      95162 | e     | М      |     8 | f
      36602 | P     | М      |    56 | f
      84982 | e     | М      |    24 | f
      13913 | ;     | Ж      |    82 | f
      65373 | 2     | Ж      |    10 | f
      19132 | p     | М      |    99 | f
      91314 | S     | М      |    45 | f
       9324 | #     | М      |    58 | f
      27741 | $     | Ж      |    18 | f
         45 | 5     | Ж      |     4 | f
(10 rows)

# Простой индекс - это индекс который мы навешиваем на столбец один к одному.
EXPLAIN
SELECT * FROM products 
    WHERE product_id = 1;
                            QUERY PLAN
    ------------------------------------------------------------
    Seq Scan on products  (cost=0.00..1887.00 rows=1 width=14)
    Filter: (product_id = 1)
    (2 rows)
# Видим что прошло чтение всей таблицы.

# Индексов нет совсем 
# \di+ — команда в PostgreSQL, которая возвращает подробную информацию об индексах в текущей базе данных.
\di+

# Диапазонный поиск
EXPLAIN
SELECT * FROM products 
    WHERE product_id < 100;
                            QUERY PLAN
    -------------------------------------------------------------
    Seq Scan on products  (cost=0.00..1887.00 rows=95 width=14)
    Filter: (product_id < 100)
    (2 rows)
# Тоже ничего не меняется.

# Создаем простые индексы:
CREATE INDEX
    idx_products_product_id
    ON products(product_id);

```
#
# 4. Прислать текстом результат команды explain, в которой используется данный индекс.
```bash

# Провести анализ таблицы
student_indexes=# ANALYZE products;
ANALYZE

# Повторно смотрим как изментся работа запроса
EXPLAIN
SELECT * FROM products 
    WHERE product_id = 1;
                                        QUERY PLAN
    -----------------------------------------------------------------------------------------
    Index Scan using idx_products_product_id on products  (cost=0.29..8.31 rows=1 width=14)
    Index Cond: (product_id = 1)
    (2 rows)
# Было (cost=0.00..1887.00 rows=95 width=14) стало (cost=0.29..8.31 rows=1 width=14)
# С индексами план работы запроса сильно лучше.  

# Повторно смотрим как изменится работа запроса
EXPLAIN
SELECT * FROM products 
    WHERE product_id < 100;
                                        QUERY PLAN
    ----------------------------------------------------------------------------------------
    Bitmap Heap Scan on products  (cost=5.09..278.57 rows=103 width=14)
    Recheck Cond: (product_id < 100)
    ->  Bitmap Index Scan on idx_products_product_id  (cost=0.00..5.07 rows=103 width=0)
            Index Cond: (product_id < 100)
    (4 rows)
# Быстрее но не так быстро как первый запроса, т.к. схема работы другая.
# Идет в два шага, 1 - определение на каких страницах памяти искать (Bitmap) и потом поиск в этих страница (Recheck Cond). 

```
### ТУТ дропнул таблицу и пересоздал чтобы products был без индексов ###
```bash
# Работа запроса ДО создания индексов:
EXPLAIN
SELECT * FROM products 
    WHERE product_id <= 100
    AND brand = 'a';
                            QUERY PLAN
    --------------------------------------------------------------
    Seq Scan on products  (cost=0.00..2108.47 rows=163 width=25)
    Filter: ((product_id <= 100) AND (brand = 'a'::bpchar))
    (2 rows)
# Вот стоимость работ без индексов - cost=0.00..2108.47

# Создаем индексы по полю (product_id):
CREATE INDEX
    idx_products_product_id
    ON products(product_id);

# Создаем индексы по полю (brand):
CREATE INDEX
    idx_products_brand
    ON products(brand);

# Проводим анализ таблицы
ANALYZE products;

# Работа запроса ПОСЕЛ создания индексов:
EXPLAIN
SELECT * FROM products 
    WHERE product_id <= 100
    AND brand = 'a';
                                            QUERY PLAN
    ---------------------------------------------------------------------------------------------
    Bitmap Heap Scan on products  (cost=17.45..21.46 rows=1 width=14)
    Recheck Cond: ((product_id <= 100) AND (brand = 'a'::bpchar))
    ->  BitmapAnd  (cost=17.45..17.45 rows=1 width=0)
            ->  Bitmap Index Scan on idx_products_product_id  (cost=0.00..4.98 rows=91 width=0)
                Index Cond: (product_id <= 100)
            ->  Bitmap Index Scan on idx_products_brand  (cost=0.00..12.22 rows=1057 width=0)
                Index Cond: (brand = 'a'::bpchar)
    (7 rows)
# План выполнения запроса стал сложнее, но стоимость упала.
# Да начальное значение - cost=17.45, а не cost=0.00, но это расходы на подготовительные работы. 
# т.е. Bitmap по первому индексу, потом Bitmap по второму, когда процесс понял на каких страницах 
# первое условие запроса и второе условие запроса, то далеее объедияем буливой логикой два этих условия.
# И Recheck Cond выполняем непосредственно поиск. 

```
#
# 5. Реализовать индекс для полнотекстового поиска.
```bash

DROP TABLE IF EXISTS testproducts;

CREATE TABLE testproducts (
  testproduct_id SERIAL NOT NULL PRIMARY KEY,
  product_name text,
  category_id INT
);

# Заполняем таблицу данными:
DO
$do$
DECLARE
BEGIN
FOR i IN 1..50
LOOP
INSERT INTO testproducts (product_name, category_id)
VALUES
('Johns Fruit Cake Johns Fruit Cake', 3),
('Marys Healthy Mix', 9),
('Peters Peters Stuff Marys Healthy Mix', 10),
('Jims Secret Recipe', 11),
('Elisabeths Best Apples', 12),
('Janes Favorite Cheese', 4),
('Billys Home Made Pizza', 13),
('Ellas Special Salmon', 8),
('Roberts Rich Spaghetti', 5),
('Mias Popular Ice Jims Secret Recipe', 14),
('Johns Fruit Cake Jims', 3),
('Marys Healthy Mix', 9),
('Peters Peters Stuff', 10),
('Jims Secret Recipe Jims', 11),
('Elisabeths Best Recipe Jims Apples', 12),
('Janes Favorite Cheese', 4),
('Billys Home Made Pizza', 13),
('Ellas Recipe Jims Special Salmon', 8),
('Roberts Rich Spaghetti', 5),
('Mias Popular Ice', 14),
('Johns Fruit Cake', 3),
('Marys Healthy Recipe Jims Jims', 9),
('Peters Scary Recipe Jims Stuff', 10),
('Jims Secret Recipe Recipe Jims', 11),
('Elisabeths Best Apples', 12),
('Janes Favorite Recipe Jims Cheese', 4),
('Billys Home Made Recipe Jims Pizza', 13),
('Marys Special Salmon', 8),
('Roberts Recipe JimsRich Spaghetti', 5),
('Mias Popular Recipe JimsIce', 14);
END LOOP;
END
$do$;

# Добавил много строк:
SELECT count(*) AS exact_count FROM testproducts;
    exact_count 
    -------------
            1500
    (1 row)

# Пример как работает план без индексов
EXPLAIN
SELECT * FROM testproducts
   WHERE product_name LIKE '%Johns%';
                            QUERY PLAN
    ----------------------------------------------------------------
    Seq Scan on testproducts  (cost=0.00..31.75 rows=150 width=33)
    Filter: (product_name ~~ '%Johns%'::text)
# Простой поиск сканом по всей таблице 

# Удаляем индексы если есть:
DROP INDEX IF EXISTS idx_testproducts_metadata;

# Создаем индекс:
CREATE INDEX
    idx_testproducts_metadata
    ON testproducts
    USING GIN (to_tsvector('english', product_name));

# Отключаем seqscan чтобы не мешал, а то покажется что мало данных.
SET enable_seqscan = OFF;

# Проводим анализ таблицы (можно выполнить не раз)
ANALYZE products;

# Запускаем запрос с использованием индексов:
EXPLAIN
SELECT * FROM testproducts
    WHERE to_tsvector('english', product_name) @@ to_tsquery('Jims');
                                                QUERY PLAN
    ---------------------------------------------------------------------------------------------------        
    Bitmap Heap Scan on testproducts  (cost=8.31..25.00 rows=8 width=33)
    Recheck Cond: (to_tsvector('english'::regconfig, product_name) @@ to_tsquery('Jims'::text))
    ->  Bitmap Index Scan on idx_testproducts_metadata  (cost=0.00..8.31 rows=8 width=0)
            Index Cond: (to_tsvector('english'::regconfig, product_name) @@ to_tsquery('Jims'::text))
    (4 rows)
# Сравниваем как было - cost=0.00..31.75 и стало - cost=8.31..25.00
# В плане работ запроса выполняет Bitmap Index поиск в каких 
# дисковых страницах искать и непосредственно поиск на этих страницах. 
# Да стоимость на подготовку стала дороже, но в общем план выполнится быстрее, 
# и чем больше данных в таблице там больше будет заметна эта разница.

```
#
# 6. Реализовать индекс на часть таблицы или индекс на поле с функцией.
```bash

# Сколько занимает индекс смотрим:
SELECT relpages
    FROM pg_class
    WHERE relname = 'idx_products_is_available';
    relpages 
    ----------
        87
    (1 row)   
# Вроде это не мало! данные на 87 дисковых страницах.
# Это 87 * 8 кб = 696 кб.

# Создаем частичный индекс:
CREATE INDEX
    idx_products_is_available_true
    ON products(is_available)
    WHERE is_available = true;
# Создали только для значений где is_available равно TRUE. 

# Проводим анализ таблицы (можно выполнить не раз)
ANALYZE products;

# И выполняем искомый запрос:
EXPLAIN
SELECT * FROM products
    WHERE is_available = true;
                                                QUERY PLAN
    -----------------------------------------------------------------------------------------------------
    Index Scan using idx_products_is_available_true on products  (cost=0.15..126.27 rows=1053 width=14)
    (1 row)
# Наш индекс idx_products_is_available_true в работе.

# Сколько занимает индекс смотрим:
SELECT relpages
    FROM pg_class
    WHERE relname = 'idx_products_is_available_true';
    relpages
    ----------
            2
    (1 row)
# А новый индекс на 2-x дисковых страницах. 2 * 8 кб = 16 кб занимает всего то места.!!!


```
#
# 7. Создать индекс на несколько полей.
```postgresql

# Проводим подготовку 
DROP TABLE IF EXISTS products;

# Создаем таблицу
CREATE TABLE products(
    product_id   integer,
    brand        char(1),
    gender       char(1),
    price        integer,
    is_available boolean
);

# Генерируем данные случайным образом 
WITH random_data AS (
    SELECT
    num,
    random() AS rand1,
    random() AS rand2,
    random() AS rand3
    FROM generate_series(1,100000) AS s(num)
)
INSERT INTO products
    (product_id, brand, gender, price, is_available)
SELECT
    random_data.num,
    chr((32 + random_data.rand1 * 94)::integer),
    case when random_data.num % 2 = 0 then 'М' else 'Ж' end,
    (random_data.rand2 * 100)::integer,
    random_data.rand3 < 0.01
    FROM random_data
    ORDER BY random();   


# Создаем индекс из несколько полей:
CREATE INDEX
    idx_products_product_id_brand
    ON products(product_id, brand);
# Важен порядок расположения полей при создании индексов.
CREATE INDEX
    idx_products_brand_product_id
    ON products(brand, product_id);

# Проводим анализ таблицы
ANALYZE products;

# Работа запроса ПОСЕЛЕ создания индексов:
EXPLAIN
SELECT * FROM products 
    WHERE product_id <= 100
    AND brand = 'a';
                                            QUERY PLAN
    -----------------------------------------------------------------------------------------------
    Index Scan using idx_products_brand_product_id on products  (cost=0.29..8.31 rows=1 width=14)
    Index Cond: ((brand = 'a'::bpchar) AND (product_id <= 100))
    (2 rows)
# brand найти проще (первым делом всегда операции строгого поиска, если не меняется смысл)
# brand у нас встал первым в плане работ и потом работы с product_id пройдут.

# И маленько другое условие:
EXPLAIN
SELECT * FROM products 
    WHERE product_id = 100
    AND brand <= 'a';
                                            QUERY PLAN
    -----------------------------------------------------------------------------------------------
    Index Scan using idx_products_product_id_brand on products  (cost=0.29..8.31 rows=1 width=14)
    Index Cond: ((product_id = 100) AND (brand <= 'a'::bpchar))
    (2 rows)
# product_id у нас встал первым в плане работ и потом работы с brand пройдут. (как в запросе)


```
#
