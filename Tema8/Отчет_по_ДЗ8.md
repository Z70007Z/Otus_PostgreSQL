
# Практика №6 "Блокировки."
# 1. Создать инстанс ВМ с 2 ядрами и 4 Гб ОЗУ и HDD 20GB.

Была создана виртуальная машина:

1. ОС - Ubuntu 24.04 LTS
2. Выделено минимально количество ресурсов
    - CPU 2 
    - RAM 4 ГБ
    - Диск HDD 20 Гб
    - Прерываемая - Да

3. В Дефолтной сети создал подсетку:
    - Имя: otus-vm-db-pg-net-1
    - ip адресация: 10.10.8.0/24
    - Динамический публичный IP адрес

4. Имя VM - otus-db-pg-vm-8

5. Для подключения по SSH воспользовался ранее сгенерированным ключом, во время создания VM указал публичный ключ.

Для подключения использовал  ПО PuTTy, можно так же Powershell и другое ПО.

#

# 2. Установить на него PostgreSQL 15 с дефолтными настройками.
```bash

# https://www.ubuntumint.com/install-postgresql-in-ubuntu/

sudo apt update && sudo apt upgrade -y
# Сначала нужно импортировать ключ PostgreSQL GPG для проверки подлинности установочного пакета:
curl -fSsL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg > /dev/null
# Импортируем стабильный репозиторий PostgreSQL 15, который, как следует из названия, содержит последнюю безопасную, рабочую и стабильную версию
echo deb [arch=amd64,arm64,ppc64el signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main | sudo tee /etc/apt/sources.list.d/postgresql.list
# Теперь нужжно обновить список источников репозитория, чтобы он отражал новые дополнения. Для этого выполним следующую команду:
sudo apt update -y
# Установка PostgreSQL с помощью следующей команды
sudo apt install postgresql-client-15 postgresql-15 -y

# Следующая команда выведет список всех пакетов, связанных с вашей установкой PostgreSQL
dpkg -l | grep postgresql
# Приведенная выше команда выводит список всех системных процессов, использующих/прослушивающих порт 5432
sudo ss -atnp | grep 5432
# Затем перезапустите PostgreSQL, чтобы он продолжал работать даже после перезагрузки системы Ubuntu, и проверьте статус PostgreSQL, чтобы убедиться, что он работает
sudo systemctl restart postgresql
sudo systemctl enable postgresql
sudo systemctl status postgresql

# Проверяем какой кластер запущен
pg_lsclusters
# или
sudo -u postgres pg_lsclusters

Ver Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log

# Картинка с выполненными командами ранее о статусе кластера (Картинка ниже!):
```
![Статус кластера](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/cluster_info.jpg "Статус кластера")

#

# 3. Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
```bash

# Добавить секцию log_lock_waits = on в файл конфигурации postgresql.conf.
# Текущее состояние:
    postgres=# show log_lock_waits;
    log_lock_waits 
    ----------------
    off
    (1 row)
# Выставляем:
    postgres=# ALTER SYSTEM SET log_lock_waits = 'on';
    ALTER SYSTEM

# Установить deadlock_timeout — время, спустя которое в журнал записываются сообщения об ожидании блокировки.
    postgres=# show deadlock_timeout;
    deadlock_timeout 
    ------------------
    1s
    (1 row)
# Выставляем, 200 миллисекунд
    postgres=# ALTER SYSTEM SET deadlock_timeout = '200ms';
    ALTER SYSTEM

# После изменения файла конфигурации нужно обновить конфигурацию командой SELECT pg_reload_conf() или перезапустить сервер.
    postgres=# SELECT pg_reload_conf();
    pg_reload_conf 
    ----------------
    t
    (1 row)

# Проверяем что установилось:
    postgres=# show log_lock_waits;
    log_lock_waits 
    ----------------
    on
    (1 row)
    postgres=# show deadlock_timeout;
    deadlock_timeout 
    ------------------
    200ms
    (1 row)
# Заданные нами параметры установились!

# Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
# Создаем табличку:
    CREATE TABLE student(
     id serial,
     fio char(100)
    );

# Заполняем ее записями:
    INSERT INTO student(fio) SELECT 'noname' FROM generate_series(1,100);


# Моделируем блокировку:
#-----------------------------------------------------
# Транзакция 1
    postgres=# begin;
    BEGIN
    postgres=*# update student set fio = 'Петров3' where id = 22;
    UPDATE 1
    postgres=*#
# Транзакция 2
    postgres=# begin;
    BEGIN
    postgres=*# update student set fio = 'Петров3' where id = 22;
    _
#-----------------------------------------------------
# Вторая транзакция в блоке.

# Устанавливаем расширение pg_stat_statements
# Кто и какие ресурсы скушал на сервере показывает.
# Установить sudo apt install postgressql-contrid если не стоит:
# В postgresql.conf пишем
    shared_preload_libraries = 'pg_stat_statements'
# И перезагрузка postgresql
    sudo systemctl restart postgresql
# И на уровни базы данный psql или другая консоль:'
    postgres=# create extension pg_stat_statements;
    CREATE EXTENSION
# Теперь можно смотреть более подробную статистику.!
    select * from pg_stat_statements
    order by total_exec_time desc
# Полный список блокировок в базе (Выод списка активных блокировок):
    SELECT * FROM pg_locks; 
# Выполняя разные запросы к этим таблицам можно узнать id базы и имя, номер транзакции, номер процесса в транзакции.
# Узнав из запроса SELECT * FROM pg_locks; transactionid (Картинка ниже!):
```
![transactionid](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/transactionid.jpg "transactionid")
```bash
# Тут он 791 выставлена блокировка ShareLock, и 791 заблокированная транзакция.
# Далее выполняем:
    SELECT * FROM crosstab (SELECT * FROM pg_stat_activity e WHERE e.backend_xid = 791);
# или
    SELECT * FROM pg_stat_activity e WHERE e.backend_xid = 792;
```
![info_mini](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/info_mini.jpg "info_mini")
```bash
# И узнаем все в подробностях.
# Вот часть информации

```
### Чтобы вывести информацию о блокировках >200мс я не нашел ((, прошу проконсультировать!!!  ###
```bash

```
#
# 4. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
```bash

# Ранее была создана таблица, будем работать с ней.
# Запуска три сессии, дна на DBeaver
# и две через psql консоль.
# На подключении с DBeaver первым обращаюсь на изменение командой UPDATE
# Картинка с выполненными командами ранее о статусе кластера (Картинка ниже!):
```
![session3](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/session3.jpg "session3")
```bash
# Видно что первая выполнилась с DBeaver но она не завершена коммитом, сессия открыта и заблокировала запись в это поле.
# Нижнее подключение показывает что сейчас на самом деле за запись в поле 22 - Петров1.

# Выполняем 
    select txid_current();
# Исмотрим текущий ID транзакции (Картинка ниже!):
```
![id транзакции](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/id_tr_block.jpg "id транзакции")
```bash
# id 759, остальные транзакции я запускал позднее и значит они на 760 и 761 должны быть.

# Выполним:
    SELECT * FROM pg_locks;
# И это видно (Картинка ниже!):
```
![id](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/id_3.jpg "id")
```bash

# Смотрим сколько всего блокировок:
    postgres=# SELECT COUNT(*) FROM pg_locks WHERE NOT granted;
    count 
    -------
        2
    (1 row)

# Определяем номер базы:
    select * from pg_database;
# Результат (Картинка ниже!):
```
![number_base](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/number_base.jpg "number_base")
```bash
# 5 - это база postgres, мы в ней и работает

# Что заблокировано:
    SELECT pid, pg_blocking_pids(pid), query FROM pg_stat_activity 
    WHERE backend_type = 'client backend' AND wait_event_type = 'Lock' 
# или:
    SELECT pid, usename,
        pg_blocking_pids(pid) AS blocked_by,
        query AS blocked_query
    FROM pg_stat_activity
    WHERE cardinality(pg_blocking_pids(pid)) > 0;
```
![what_Block](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/what_Block.jpg "what_Block")
```bash
# Для процесса 4122 блокирующий pid 4055, а для 4055 блокирующий 4400.
# Процесс 4400 нужно на найти и удалить.! 
```
### Процесс 4400 далее будет 4740 (т.к. экспериментируя сбросил первую транзакцию. И txid_current() = 773) - номер блокирующий транзакции!!!  ###

```bash
# Выполнив команду 
    SELECT * FROM pg_stat_activity e WHERE pid = 4740;
```
![backend_id](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/backend_id.jpg "backend_id")
```bash
# Можно увидеть backend_id транзакции что блокирует работы с полем.
# Если ввести из блокирующей транзакции команду:
    select txid_current();
# то получим тоже 773.

# Или самый простой вариант 
# Это через Dbiver диспетчер блокировок:
```
![From_dbiver](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema8/picture/From_dbiver.jpg "From_dbiver")
```bash
# Все прекрасно видно и можно далее через Диспетчер сессий удалить проблемную.

```
#
# Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
```bash

# Ну если трех я не знаю наверно это довольно сложно сделать руками:
# Вот запускаем на транзакции:
# Итерация 1
# ----------------------------------------------------
# Транзакция 1
begin;
	update student set fio = 'Петров3' where id = 22;
end;
# Транзакция 2
begin
	update student set fio = 'Петров3' where id = 23;
end;
# Транзакция 3
begin;
	update student set fio = 'Петров3' where id = 24;
end;
# ----------------------------------------------------
# Транзакцию не завершаем

# Итерация 2
# ----------------------------------------------------
# Транзакция 1
begin;
	update student set fio = 'Петров3' where id = 23;
end;
# Транзакция 2
begin;
	update student set fio = 'Петров3' where id = 24;
end;
# Транзакция 3
begin;
	update student set fio = 'Петров3' where id = 22;
end;
# ----------------------------------------------------
# Я думаю что если взаимная блокировка из трех транзакций, то это кольцевая блокировка.

# Что вышло:
# Транзакция 1 осталась заблокированная.
postgres=# begin;
    BEGIN
    postgres=*# update student set fio = 'Петров3' where id = 22;
    UPDATE 1
    postgres=*# update student set fio = 'Петров3' where id = 23;
    _
# Транзакция 2 выполнила операцию, ждет дальнейших команд.
    postgres=# begin;
    BEGIN
    postgres=*# update student set fio = 'Петров3' where id = 23;
    UPDATE 1
    postgres=*# update student set fio = 'Петров3' where id = 24;
    UPDATE 1
    postgres=*#
# Транзакция 3 отлетела с ошибкой.
    postgres=*# update student set fio = 'Петров3' where id = 22;
    ERROR:  deadlock detected
    DETAIL:  Process 6415 waits for ShareLock on transaction 784; blocked by process 6538.
    Process 6538 waits for ShareLock on transaction 785; blocked by process 6602.
    Process 6602 waits for ShareLock on transaction 786; blocked by process 6415.
    HINT:  See server log for query details.
    CONTEXT:  while updating tuple (1,48) in relation "student"
    postgres=!#

# В диспетчере видны блокировки.
# Кто кого блокирует сейчас
    SELECT activity.pid, activity.usename, activity.query, blocking.pid AS blocking_id, blocking.query AS blocking_query 
    FROM pg_stat_activity AS activity JOIN pg_stat_activity AS blocking ON blocking.pid = ANY(pg_blocking_pids(activity.pid)) 
    ORDER BY activity.query_start;
# Получаем:
6538	postgres	update student set fio = 'Петров3' where id = 23;	6602	update student set fio = 'Петров3' where id = 24;
# Да и из ошибки выше видно кто кого блокировал.
# А из запроса какие процессы пытаются выполнится. 
```
### Прошу уточнить как можно еще смотреть и в каким журнале если я не прав. ###
```bash

```
#
# Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
```bash

# Проверяем:
# Транзакция 1
    begin;
        update student set fio = (fio || '_1');
# Транзакция 2
    begin;
        update student set fio = (fio || '_2');

# Результат:
# Транзакция 1
    postgres=# begin;
    BEGIN
    postgres=*# update student set fio = (fio || '_1');
    UPDATE 100
    postgres=*#
# Транзакция 2
    postgres=# begin;
    BEGIN
    postgres=*# update student set fio = (fio || '_2');
    _
# Вторая транзакция поймала блокировку. !!!

```
#
