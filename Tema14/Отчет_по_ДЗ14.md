
# Практика №14 "Виды и устройство репликации в PostgreSQL. Практика применения."
# 1. Создать ВМ с 2 ядрами и 4 Гб ОЗУ и HDD 20GB (4 сервера).

Было создано 4 виртуальные машина:

1. ОС - Ubuntu 24.04 LTS
2. Выделено минимально количество ресурсов
    - CPU 2 
    - RAM 4 ГБ
    - Диск HDD 20 Гб
    - Прерываемая - Да

3. В Дефолтной сети создал подсетку:
    - Имя: otus-vm-db-pg-net-1
    - ip адресация: 10.10.8.0/24
    - Динамический публичный IP адрес

4. Имя VM - otus-db-pg-vm1-14
          - otus-db-pg-vm2-14
          - otus-db-pg-vm3-14
          - otus-db-pg-vm4-14

5. Для подключения по SSH воспользовался ранее сгенерированным ключом, во время создания VM указал публичный ключ.

Для подключения использовал  ПО PuTTy, можно так же Powershell и другое ПО.

#

# 2. Установить на него PostgreSQL 15 с дефолтными настройками на все сервера.
```bash

# https://www.ubuntumint.com/install-postgresql-in-ubuntu/

sudo apt update && sudo apt upgrade -y
# Сначала нужно импортировать ключ PostgreSQL GPG для проверки подлинности установочного пакета:
curl -fSsL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg > /dev/null
# Импортируем стабильный репозиторий PostgreSQL 15, который, как следует из названия, содержит последнюю безопасную, рабочую и стабильную версию
echo deb [arch=amd64,arm64,ppc64el signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main | sudo tee /etc/apt/sources.list.d/postgresql.list
# Теперь нужжно обновить список источников репозитория, чтобы он отражал новые дополнения. Для этого выполним следующую команду:
sudo apt update -y
# Установка PostgreSQL с помощью следующей команды
sudo apt install postgresql-client-15 postgresql-15 -y

# Следующая команда выведет список всех пакетов, связанных с вашей установкой PostgreSQL
dpkg -l | grep postgresql
# Приведенная выше команда выводит список всех системных процессов, использующих/прослушивающих порт 5432
sudo ss -atnp | grep 5432
# Затем перезапустите PostgreSQL, чтобы он продолжал работать даже после перезагрузки системы Ubuntu, и проверьте статус PostgreSQL, чтобы убедиться, что он работает
sudo systemctl restart postgresql
sudo systemctl enable postgresql
sudo systemctl status postgresql

# Проверяем какой кластер запущен
pg_lsclusters
# или
sudo -u postgres pg_lsclusters

Ver Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log

# Картинка с выполненными командами ранее о статусе кластера (Картинка ниже!):
```
![Статус кластера](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema13/picture/status_cluster.jpg "Статус кластера")
```bash

# И так настраиваем для каждого сервера!!!!!!!!!!
otus-db-pg-vm1-14
otus-db-pg-vm2-14
otus-db-pg-vm3-14
otus-db-pg-vm4-14

```
#
# Настройки подключения postgres.
```bash

# Смотрим где конфиг файлы:
sudo -u postgres psql -c "SHOW config_file;"
could not change directory to "/home/admin_s": Permission denied
               config_file
-----------------------------------------
 /etc/postgresql/15/main/postgresql.conf
(1 row)

# Для удобства будем использовать pgAdmin 4. (а для этого нужно открыть прослушивание ip)
sudo nano /etc/postgresql/15/main/postgresql.conf
# Открываю для всех, т.к. у меня не белый адрес:
listen_addresses = '*'         # what IP address(es) to listen on;
# И перечитываем конфиг
sudo systemctl restart postgresql
# И да порт стал доступен.

# Настраиваем разрешение на подключение к базам:
sudo nano /etc/postgresql/15/main/pg_hba.conf
# Ко всем базам с любых ip: 
# host all all 0.0.0.0/0 md5
# И перечитываем конфиг
sudo systemctl restart postgresql

# Еще нужно задать пароль для УЗ postgres:
sudo -u postgres psql
postgres=# \password 
# и задаем пароль который буде вводить в приложении для подключении к базе.
# И да результат не заставил себя ждать.

# И так настраиваем для каждого сервера!!!!!!!!!!
otus-db-pg-vm1-14
otus-db-pg-vm2-14
otus-db-pg-vm3-14
otus-db-pg-vm4-14

```
#

# План работ написан довольно странно, местами подключение, создание таблиц и подписка не последовательно выглядит.
# Выполнил так как считаю логичным.

## 1. На 1 ВМ создаем таблицы test для записи, На 2 ВМ создаем таблицы test2 для записи.
```bash
# Это те таблица из которых будем забирать данные после того, как опубликуем их.

# Входим в psql На ВМ 1:
  sudo -u postgres psql

# Создаю таблицу test:
  postgres=# CREATE TABLE test (
    id serial,
    fio char(100)
  );
  CREATE TABLE

# Входим в psql ВМ 2:
  sudo -u postgres psql

# Создаю таблицу test2:
  postgres=# CREATE TABLE test2 (
    id serial,
    fio2 char(100)
  );
  CREATE TABLE

```
##
## 2. На 1 ВМ создаем таблицу test2 для запросов на чтение, На 2 ВМ создаем таблицу test для запросов на чтение
```bash
# Это те таблицы в которые будем забирать данные после того, как подпишемся.

# --------------------------------------------------------------------------------------------------------------------------

# Создаю таблицу test2:
# test2 существует на ВМ №2.
# Я ее создам на сервере ВМ №1 как показывали на уроке через pgAdmin 4

# Подключается к серверу ВМ №2 pgAdmin 4 и правой кнопкой на нужную таблицу, - scripts - CREATE Scripts (картинка ниже!):
```
![Create_test2](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Create_test2.jpg "Create_test2")
```bash
# Открывается запрос создания таблицы.
# Далее копирую блок CREATE TABLE (картинка ниже!):
```
![scrripts_CREATE_test2](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/scripts_CREATE_test2.jpg "scrripts_CREATE_test2")
```bash

# Идем на сервере ВМ №1 правой кнопкой по базе где будем лежать таблица - нажимаем Query tool (картинка ниже!):
```
![Query_tool](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Query_tool_vm1.jpg "Query_tool")
```bash

# далее вставляем блок CREATE TABLE что скопировали из ВМ №2 и убираем лишнее (картинка ниже!):
```
![Cteate_test2_VM1](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Cteate_test2_VM1.jpg "Cteate_test2_VM1")
```bash
# Лишнее подчеркнул красным.

# --------------------------------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------------------------------

# Создаю таблицу test:
# test существует на ВМ №1.
# Я ее создам на сервере ВМ №2 как показывали на уроке через pgAdmin 4

# Подключается к серверу ВМ №1 pgAdmin 4 и правой кнопкой на нужную таблицу, - scrripts - CREATE Scripts (картинка ниже!):
```
![Create_test](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Create_test.jpg "Create_test")
```bash
# Открывается запрос создания таблицы.
# Далее копирую блок CREATE TABLE (картинка ниже!):
```
![scrripts_CREATE_test](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/scripts_CREATE_test.jpg "scrripts_CREATE_test")
```bash

# Идем на сервере ВМ №2 правой кнопкой по базе, где будем лежать таблица - нажимаем Query tool (картинка ниже!):
```
![Query_tool](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Query_tool_vm2.jpg "Query_tool")
```bash

# далее вставляем блок CREATE TABLE что скопировали из ВМ №1 и убираем лишнее (картинка ниже!):
```
![Cteate_test_VM2](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Cteate_test_VM2.jpg "Cteate_test_VM2")
```bash
# Лишнее подчеркнул красным.

# --------------------------------------------------------------------------------------------------------------------------
```
##
## 3. Создаем публикацию таблицы test ВМ №1 и Создаем публикацию таблицы test2 ВМ №2.
```bash

VM1
# --------------------------------------------------------------------------------------------------------------------------
# Поднять уровень подробности ведения журнала
# Заходим в файл
sudo nano /etc/postgresql/15/main/postgresql.conf
# И ставим значение wal_level = logical

# Делаем так:(картинка ниже!):
```
![wal_level](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/wal_level.jpg "wal_level")
```bash

# Далее в файле:
sudo nano /etc/postgresql/15/main/pg_hba.conf
# Разрешаем делать реплику откуда угодно
# заменяем локальное разрешение 127.0.0.1/32 на 0.0.0.0/0

# Делаем так:(картинка ниже!):
```
![Replica](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Replica.jpg "Replica")
```bash

# Применяем сделанные изменения:
sudo systemctl restart postgresql

# Создать спец. УЗ от имени которой будет производиться репликация:
# Идем на VM1 через pgAdmin, там на Login/Group Roles правой кнопкой - далее Create - далее Login/Group Roles...
```
![Login_vm1_R](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Login_vm1_R.jpg "Login_vm1_R")
```bash

# Создаю УЗ Replica_vm1 в General
# Создаю пароль в Definition
# И в разделе Privileges включаю параметры - 
# - Can login (что отмечаем, создаю УЗ)
# - Can initiate streaming replication and backup (от этой уз можно запустить потоковую репликацию и бэкап)

# Результат смотреть ниже:
```
![Create_user](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Create_user.jpg "Create_user")
```bash


# Выдаем права УЗ на таблички которые будем реплицировать.
# Встаем правой кнопкой на табличку test - далее Properties.. - далее вкладка Security - далее плюсик в блоке Privileges
# Выбираю нужного пользователя и права на чтение, сохраняем

# Результат смотреть ниже:
```
![PR_user_VM1](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/PR_user_VM1.jpg "PR_user_VM1")
```bash

# ----------------------------------------------------------
# Создаю непосредственно публикацию (фильтр что передавать):
# Переходим на сервер VM1 - далее по вкладке Publications правой кнопкой - Create - Publication...
# Делаем так:
```
![vm1_Puble](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm1_Puble.jpg "vm1_Puble")
```bash

# Вкладка General - Присвамваем имя публикации
# Вкладка Tables - нажимаем плюсик и выбираем таблицу для публикации (можно настроить какие поля публиковать и при каких операциях передавать данные)
# Так это выглядит:
```
![vm1_Puble_Properties](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm1_Puble_Properties.jpg "vm1_Puble_Properties")
```bash


# --------------------------------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------------------------------
VM2
# --------------------------------------------------------------------------------------------------------------------------
# Поднять уровень подробности ведения журнала
# Заходим в файл
sudo nano /etc/postgresql/15/main/postgresql.conf
# И ставим значение wal_level = logical

# Делаем так:(картинка ниже!):
```
![wal_level](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/wal_level.jpg "wal_level")
```bash

# Далее в файле:
sudo nano /etc/postgresql/15/main/pg_hba.conf
# Разрешаем делать реплику откуда угодно
# заменяем локальное разрешение 127.0.0.1/32 на 0.0.0.0/0

# Делаем так:(картинка ниже!):
```
![Replica](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Replica.jpg "Replica")
```bash

# Применяем сделанные изменения:
sudo systemctl restart postgresql

# Создать спец. УЗ от имени которой будет производиться репликация:
# Идем на VM1 через pgAdmin, там на Login/Group Roles правой кнопкой - далее Create - далее Login/Group Roles...
```
![Login_vm2_R](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Login_vm2_R.jpg "Login_vm2_R")
```bash

# Создаю УЗ Replica_vm2 в General
# Создаю пароль в Definition
# И в разделе Privileges включаю параметры - 
# - Can login (это значит что создаю УЗ)
# - Can initiate streaming replication and backup (от этой уз можно запустить потоковую репликацию и бэкап)

# Результат смотреть ниже:
```
![Create_user](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/Create_user2.jpg "Create_user")
```bash


# Выдаем права УЗ на таблички, которые будем реплицировать.
# Встаем правой кнопкой на табличку test - далее Properties.. - далее вкладка Security - далее плюсик в блоке Privileges
# Выбираю нужного пользователя и права на чтение, сохраняем

# Результат смотреть ниже:
```
![PR_user_VM2](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/PR_user_VM2.jpg "PR_user_VM2")
```bash

# ----------------------------------------------------------
# Создаю непосредственно публикацию (фильтр что передавать):
# Переходим на сервер VM1 - далее по вкладке Publications правой кнопкой - Create - Publication...
# Делаем так:
```
![vm2_Puble](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm2_Puble.jpg "vm2_Puble")
```bash

# Вкладка General - Присвамваем имя публикации
# Вкладка Tables - нажимаем плюсик и выбираем таблицу для публикации (можно настроить какие поля публиковать и при каких операциях передавать данные)
# Так это выглядит:
```
![vm2_Puble_Properties](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm2_Puble_Properties.jpg "vm2_Puble_Properties")
```bash
# --------------------------------------------------------------------------------------------------------------------------

```
##
## 4. Подписываемся на публикацию таблицы test с ВМ №1 и Подписываемся на публикацию таблицы test2 с ВМ №2
```bash

# На сервере ВМ №1 подписывается на табличку test2 с ВМ №2.
# Переходитм на сервер VM1 - далее по вкладке Subscriptions правой кнопкой - Create - Subscription...
# Делаем так:
```
![vm1_subscriptions](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm1_subscriptions.jpg "vvm1_subscriptions")
```bash

# Вкладка General - Присваиваем имя подписки
# Вкладка Connection заполняем (ip, порт, база, пользователь и пароль) 
# В поле Publucation нажимаем округлую стрелочку и если все успешно появится публикация, ее нужно вабрать и нажать сохранить.
# У меня ip внешний в проме будет локальной сети:
```
![vm1_subscriptions_properties](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm1_subscriptions_properties.jpg "vm1_subscriptions_properties")
```bash

#-------------------------------------------------------------

# На сервере ВМ №2 подписывается на табличку test с ВМ №1.
# Переходим на сервер VM2 - далее по вкладке Subscriptions правой кнопкой - Create - Subscription...
# Делаем так:
```
![vm2_subscriptions](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm2_subscriptions.jpg "vvm2_subscriptions")
```bash

# Вкладка General - Присваиваем имя подписки
# Вкладка Connection заполняем (ip, порт, база, пользователь и пароль) 
# В поле Publucation нажимаем округлую стрелочку и если все успешно появится публикация, ее нужно выбрать и нажать сохранить.
# У меня ip внешний в проме будет локальной сети:
```
![vm2_subscriptions_properties](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm2_subscriptions_properties.jpg "vm2_subscriptions_properties")
```bash


# Проверил что работает. 
# Добавил данные на сервере
  INSERT INTO test(fio) SELECT 'test' FROM generate_series(1,1);
  INSERT 0 1

# И данные появились на втором сервере.
  SELECT * FROM test LIMIT 5;
  id |  fio
  ----+-------     
    1 | test
  (1 row)

# Добавил данные на сервере
  INSERT INTO test2(fio2) SELECT 'test2' FROM generate_series(1,1);
  INSERT 0 1

# И данные появились на втором сервере.
  SELECT * FROM test LIMIT 5;
  id |  fio2
  ----+-------     
    1 | test2
  (1 row)


```
##
## 5. 3 ВМ использовать как реплику для чтения и бэкапов (подписаться на таблицы из ВМ №1 и №2 ).
```bash

# 1. На сервере ВМ №3 создаем так же пустые базы test и test2.
# По аналогии как делал выше в пункте 2

# Выполняю на сервере 3 команды создания пустой таблицы test:
  CREATE TABLE IF NOT EXISTS public.test
  (
      id integer NOT NULL,
      fio character(100) COLLATE pg_catalog."default"
  )
# и для создания пустой таблицы test2:
  CREATE TABLE IF NOT EXISTS public.test2
  (
      id integer NOT NULL,
      fio2 character(100) COLLATE pg_catalog."default"
  )

# а именно выполняем и получаем: (рисунок ниже)
```
![vm3_create_table](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm3_create_table.jpg "vm3_create_table")
```bash


#-------------------------------------------------------------
# И далее настройка подписки к серверу 1 за таблицей test:
```
![vm1_subscriptions](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm3_sab1.jpg "vvm1_subscriptions")
```bash

# И далее настройка подписки к серверу 2 за таблицей test2:
```
![vm2_subscriptions](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm3_sab2.jpg "vvm2_subscriptions")
```bash


# Выполняю команду для проверки:
  SELECT * FROM test LIMIT 5;
  id |  fio
  ----+-------     
    1 | test
# И вижу, что данные с сервера 1 таблицы test реплицируются.
  SELECT * FROM test2 LIMIT 5;
  id |  fio2
  ----+-------     
    1 | test2
# И вижу, что данные с сервера 2 таблицы test2 реплицируются.

  (1 row)
```
##
## * реализовать горячее реплицирование для высокой доступности на 4ВМ. Источником должна выступать ВМ №3. Написать с какими проблемами столкнулись.
```bash

Настройте основного сервер PostgreSQL.
#-----------------------------------------------------------------------
# Создать роль repuser с правами на репликацию и установленным паролем.
# Переходим в пользователя postgres
sudo su - postgres
# Создание роли:
createuser --replication -P repuser
# Установить параметр wal_level в значение replica
sudo nano /etc/postgresql/15/main/postgresql.conf
# раскомментировать строку wal_level = replica

# С IP-адреса резервного (у моего резервного ip - 10.10.8.20) сервера настройте аутентификацию для repuser с возможностью репликации
# Добавьте в файл:
sudo nano /etc/postgresql/15/main/pg_hba.conf
# такую строку:
host  replication   repuser   10.10.8.20/32      scram-sha-256



Настройте резервный сервер PostgreSQL.
#-----------------------------------------------------------------------
# Раскомментировать в файле /etc/postgresql/14/main/postgresql.conf строку hot_standby = on. 
# Этот параметр позволит нашему резервному серверу обслуживать запросы параллельно с главным, но только на чтение.
sudo nano /etc/postgresql/15/main/postgresql.conf
hot_standby = on

# Скопируем базы с основного сервера на резервный с помощью команды pg_basebackup.
sudo su - postgres
rm -rf /var/lib/postgresql/15/main/*
pg_basebackup -h 10.10.8.22 -D /var/lib/postgresql/15/main -U repuser -P -v -R
# после ввода пароля процесс запускается 
# Как вышло ниже:
```
![vm4_pg_basebackup](https://github.com/Z70007Z/Otus_PostgreSQL/blob/main/Tema14/picture/vm4_pg_basebackup.jpg "vm4_pg_basebackup")
```bash

#----------------------------------------
# Проверяем что реплика проходит
# Идем на сервер vm1 и добавляем данные в таблицу test:
INSERT INTO test (fio) VALUES ('testee')
INSERT 0 1
# Идем на сервер vm2 и добавляем данные в таблицу test2:
INSERT INTO test2 (fio2) VALUES ('testee2')
INSERT 0 1


# Читаем на сервер vm4 что в таблицах test и test2:
  postgres=# SELECT * FROM test LIMIT 5;
  id |  fio
  ----+--------
    1 | test
    2 | testee
  (2 rows)
  #-------------------------------
  postgres=# SELECT * FROM test2 LIMIT 5;
  id |  fio2
  ----+---------
    1 | test2
    2 | testee2
  (2 rows)

# Видно что реплика работает как часики.
# Проблем нет, если делать не раз и внимательно поработать с файлами конфигурации.
# Если конечно, я выполнил все согласно требованиям.

```
##